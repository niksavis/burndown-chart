# Feature Specification: Standalone Executable Packaging

**Feature Branch**: `016-standalone-packaging`  
**Created**: 2025-12-23  
**Updated**: 2026-01-17  
**Status**: Completed  
**Completion Date**: 2026-01-17  
**Input**: User description: "Make installation of the app extremely easy and convenient for Windows users (primarily), with optional support for Linux/macOS. Package app as standalone executable with all dependencies prepackaged, so it can run immediately after download. App should check for updates on every start and auto-update from GitHub releases. Needs investigation: two-executable approach (one for app, one for updater) and best practices for browser launching vs. terminal window management."

**Completion Notes**: 
- PyInstaller-based build system successfully packages app into standalone Windows executable
- InstallationContext system detects frozen/source modes and manages paths appropriately
- GitHub Actions workflow automates build, release creation, and asset upload
- Update manager checks for new releases and downloads updates
- Comprehensive documentation for build, release, and signing processes
- All beads tasks closed
- All quality gates passed (tests, zero errors)

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Download and Run (Priority: P1)

Non-technical users can download a single executable file, double-click to run the app, and immediately start using it without installing Python, Git, or any development tools. The app launches in the user's default browser or provides clear instructions via terminal window.

**Why this priority**: Eliminates the largest barrier to adoption. Most users don't have Python installed and don't want to use terminals or IDEs. Single-click execution is essential for mainstream adoption.

**Independent Test**: Download executable on clean Windows system without Python, double-click file, verify app launches and opens browser or displays URL within 5 seconds.

**Acceptance Scenarios**:

1. **Given** user downloads standalone executable on Windows without Python installed, **When** user double-clicks the file, **Then** app server starts and automatically opens default browser to app URL OR displays terminal with clickable URL
2. **Given** app is running from executable, **When** user enters JIRA credentials in Settings, **Then** app connects and loads issues without errors
3. **Given** app launches for first time, **When** app initializes, **Then** database file is created in same directory as executable
4. **Given** user closes and reopens app, **When** app restarts, **Then** previous settings and data persist from database
5. **Given** user has no network connection, **When** app launches, **Then** app opens with cached data (no crash on offline mode)
6. **Given** user closes browser tab/window, **When** browser closes, **Then** app server continues running (can reopen at same URL)
7. **Given** app is running in terminal, **When** user closes terminal window, **Then** app server shuts down gracefully and releases all resources

---

### User Story 2 - Automated GitHub Release Process (Priority: P1)

Developers can trigger automated build and release process that packages app into Windows executable (with separate updater executable), creates GitHub release with proper formatting, uploads assets, and provides clear installation instructions for both standalone and source code approaches.

**Why this priority**: Manual releases are error-prone and time-consuming. Automated releases ensure consistent packaging, proper versioning, professional presentation, and seamless integration with the update mechanism. Without automation, releasing becomes a bottleneck.

**Independent Test**: Trigger release workflow, verify GitHub release created with proper structure, download assets, test installation instructions work for both standalone and source approaches.

**Acceptance Scenarios**:

1. **Given** developer triggers release workflow (tag push or manual), **When** build completes, **Then** GitHub release is created with version number, changelog, and assets
2. **Given** release is created, **When** viewing release page, **Then** release includes: title ("Burndown Chart v{version}"), automated changelog, installation instructions section, and downloadable assets
3. **Given** build process completes, **When** assets are uploaded, **Then** release includes: `burndown-chart-windows-v{version}.zip` (containing app.exe + updater.exe), source code archives (auto-generated by GitHub)
4. **Given** release notes are generated, **When** user views release, **Then** installation instructions clearly distinguish "Windows Standalone" vs "Run from Source" with step-by-step guidance
5. **Given** Windows standalone zip is downloaded, **When** user extracts, **Then** archive contains: app.exe, updater.exe, README.txt (quick start), LICENSE files directory, and initial database will be created on first run
6. **Given** release workflow runs, **When** packaging fails, **Then** workflow fails gracefully with clear error message and no partial release is published
7. **Given** multiple releases exist, **When** update mechanism queries GitHub, **Then** app correctly identifies latest release from GitHub API

---

### User Story 3 - Automated Build Process (Priority: P1)

Developers can trigger automated build process that packages Python app into standalone Windows executable with all dependencies bundled, producing distributable file ready for release.

**Why this priority**: Without automated packaging, manual builds are error-prone and time-consuming. Automation ensures consistent, reproducible releases and enables CI/CD workflows.

**Independent Test**: Run build command, verify executable is created with correct version, test executable launches successfully and passes smoke tests.

**Acceptance Scenarios**:

1. **Given** developer runs build command, **When** packaging process completes, **Then** standalone executable is created in `dist/` directory
2. **Given** build process runs, **When** executable is generated, **Then** all Python dependencies are bundled (Dash, Plotly, Waitress, etc.)
3. **Given** build completes, **When** executable metadata is inspected, **Then** version number matches app version from `bump_version.py`
4. **Given** executable is built, **When** file is scanned by antivirus, **Then** no false positives detected (proper code signing)
5. **Given** build fails, **When** error occurs, **Then** clear error message indicates what failed (missing dependencies, invalid config, etc.)

---

### User Story 4 - Automatic Update Mechanism (Priority: P2)

Packaged app checks for updates on every launch, automatically downloads new version from GitHub releases when available, and allows one-click update installation without requiring Git or terminal commands. May require separate updater executable to handle replacing running app executable.

**Why this priority**: Users expect modern apps to auto-update. Without this, users must manually download new versions, leading to fragmented version distribution and support complexity. Checking on every launch ensures users stay current with minimal friction.

**Independent Test**: Simulate new version release, launch outdated executable, verify update check occurs, notification appears, and download/installation works.

**Acceptance Scenarios**:

1. **Given** new version is released on GitHub, **When** user launches outdated executable, **Then** app checks GitHub releases API and notification appears: "Version X.Y.Z available - Update Now"
2. **Given** user clicks "Update Now", **When** download completes from GitHub, **Then** update is applied (via separate updater executable if needed) and app restarts with new version
3. **Given** update download fails (network error, GitHub unavailable), **When** error occurs, **Then** app continues running current version and retries check on next launch
4. **Given** user dismisses update notification, **When** app launches next time, **Then** update check runs again and notification reappears (persistent but not intrusive)
5. **Given** user is on latest version, **When** app checks for updates on launch, **Then** no notification appears and app continues normally
6. **Given** update requires replacing running executable, **When** update is applied, **Then** separate updater executable handles the replacement process to avoid file locking issues
7. **Given** update check occurs, **When** GitHub API is queried, **Then** check completes within 2 seconds and doesn't block app UI from appearing

---

### User Story 5 - Local Data Persistence (Priority: P2)

Packaged executable creates and maintains database file in same directory as executable, allowing users to keep all data (settings, cache, metrics) portable with the executable.

**Why this priority**: Enables portable installation where users can move executable to different locations or machines. Critical for users who want to run app from USB drives or shared network folders.

**Independent Test**: Copy executable and database to new directory, run app, verify all data loads correctly from co-located database.

**Acceptance Scenarios**:

1. **Given** app launches for first time in directory, **When** initialization completes, **Then** `burndown.db` file is created in same directory
2. **Given** user moves executable and database to different directory, **When** app launches, **Then** app loads data from co-located database file
3. **Given** database file is missing, **When** app launches, **Then** app creates new empty database and prompts for initial setup
4. **Given** multiple users share app on network drive, **When** each user runs app, **Then** each user's instance uses separate database (user-specific path strategy)

---

### User Story 6 - Cross-Platform Distribution (Priority: P3)

Linux and macOS users can download source code as ZIP from main branch and run app using standard Python commands, while Windows users get dedicated standalone executable for convenience.

**Why this priority**: Windows represents majority of non-technical users who need packaging. Linux/macOS users typically have Python development environment and can run from source. Focusing packaging effort on Windows maximizes user impact while providing fallback option for other platforms.

**Independent Test**: Download source ZIP on Linux/macOS, extract, run documented Python commands, verify app launches successfully.

**Acceptance Scenarios**:

1. **Given** Linux/macOS user downloads source ZIP, **When** user extracts and follows README instructions, **Then** app runs using Python commands (`python app.py`)
2. **Given** Windows user prefers source approach, **When** user has Python installed, **Then** source ZIP option also works on Windows
3. **Given** documentation exists for both approaches, **When** users visit releases page, **Then** clear instructions distinguish standalone executable (Windows) from source ZIP (all platforms)
4. **Given** updates are released, **When** source ZIP users want to update, **Then** they follow standard Git pull or re-download ZIP approach (no auto-update for source distribution)

---

### User Story 7 - Error Logging Without Terminal (Priority: P3)

Packaged app writes errors and diagnostics to log files in same directory, allowing users to troubleshoot issues or send logs to support without needing terminal access.

**Why this priority**: Enables self-service troubleshooting and support. Without terminal output, users have no visibility into errors when things go wrong.

**Independent Test**: Trigger error condition (invalid JIRA credentials), close app, verify error logged to file with timestamp and details.

**Acceptance Scenarios**:

1. **Given** app encounters error, **When** error occurs, **Then** error details are written to `logs/app.log` with timestamp
2. **Given** user reports issue, **When** support asks for logs, **Then** user can send `logs/` directory without technical knowledge
3. **Given** log files grow large, **When** app launches, **Then** old logs are rotated (keep last 10 files or 10MB)

---

### User Story 8 - License Transparency and Legal Compliance (Priority: P3)

Users can access complete license information for all bundled open source dependencies through an in-app About dialog, while distribution includes bundled license files for full legal compliance.

**Why this priority**: Professional applications provide transparent attribution to open source contributors. Legal compliance requires distributing license texts. Combining bundled files (legal) with in-app display (UX) is industry standard (VS Code, Electron, Firefox).

**Independent Test**: Open About dialog, verify all dependencies listed with licenses and links, confirm bundled licenses/ directory exists with complete license texts.

**Acceptance Scenarios**:

1. **Given** user clicks About button in footer, **When** About modal opens, **Then** modal displays tabs for App Info and Open Source Licenses
2. **Given** user views Licenses tab, **When** tab loads, **Then** all dependencies are listed with package name, license type, and link to repository
3. **Given** user wants complete license text, **When** user navigates to licenses/ directory in executable location, **Then** THIRD_PARTY_LICENSES.txt contains full license texts for all dependencies
4. **Given** executable is distributed, **When** package is inspected, **Then** licenses/ directory contains LICENSE.txt (app), NOTICE.txt (Apache 2.0 attributions), and THIRD_PARTY_LICENSES.txt
5. **Given** user searches for specific package license, **When** user types in filter box, **Then** license list filters to matching packages

---

### Edge Cases

- What happens when executable runs from read-only location (CD-ROM, protected system folder)?
- How does system handle file size limits for single-file executable (large dependencies)?
- What if Windows Defender or antivirus blocks execution (unsigned executable)?
- How does app behave when required system DLLs are missing on user's machine?
- What if user runs multiple versions of executable simultaneously from different directories?
- How does update mechanism work when user doesn't have write permissions to executable directory?
- What if download server for updates is unreachable or returns invalid data?
- What if user's default browser is not set or fails to launch automatically?
- What if user manually closes terminal window while app server is running in background?
- What if updater executable is running and user tries to launch main app simultaneously?
- What if GitHub releases API rate limiting blocks update checks?
- What if user has multiple browser tabs open and terminal control is lost?
- What if test dependencies (pytest, playwright) are accidentally bundled increasing executable size?
- What if development-only packages are included that have security implications?
- What if bundled dependencies have incompatible licenses (GPL vs proprietary)?
- What if dependency licenses require including their license files in distribution?
- What if dependency license has copyleft requirements that affect main app license?

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: System MUST provide automated build script that packages Python app into standalone Windows executable
- **FR-002**: Build process MUST create TWO separate executables: main app executable and updater executable
- **FR-003**: Build process MUST bundle all Python dependencies (Dash, Plotly, Waitress, Bootstrap Components, etc.) into executables
- **FR-003**: Build process MUST exclude development and testing dependencies (pytest, playwright, etc.) from executable to minimize size
- **FR-004**: Executable MUST run on Windows 10+ without requiring Python installation
- **FR-004**: Executable MUST create database file in same directory on first launch
- **FR-005**: Executable MUST detect co-located database file and use it for persistence across launches
- **FR-006**: Executable MUST include app version metadata visible in Windows file properties
- **FR-007**: Build process MUST digitally sign executable to prevent antivirus false positives
- **FR-008**: Executable MUST write error logs and diagnostics to `logs/` subdirectory in executable location
- **FR-009**: App MUST check for updates on launch by querying version endpoint (GitHub releases or hosted JSON)
- **FR-010**: App MUST display in-app notification when new version is available with "Download Update" button
- **FR-011**: Update download MUST retrieve new executable and prompt user to restart with new version
- **FR-012**: App MUST handle update download failures gracefully and continue running current version
- **FR-013**: Update mechanism MUST NOT require Git, terminal commands, or Python installation
- **FR-014**: App MUST detect read-only installation directory and prompt user to run from writable location
- **FR-015**: Build process MUST produce executable <100MB in size for reasonable download times
- **FR-016**: Executable MUST display splash screen during initialization to indicate app is loading
- **FR-017**: App MUST support portable mode where database and logs stay with executable regardless of location
- **FR-018**: Build script MUST validate all dependencies are included before finalizing executable
- **FR-019**: Build script MUST verify no test/development dependencies are bundled in production executable
- **FR-020**: Update endpoint MUST serve version metadata including version number, release date, download URL, and changelog
- **FR-020**: App MUST allow users to skip version updates and not be forced to upgrade
- **FR-021**: App MUST attempt to open default web browser automatically on launch with app URL
- **FR-022**: App MUST display terminal window with clickable URL if browser auto-launch fails or is disabled
- **FR-023**: Terminal window MUST remain visible while app is running to provide shutdown control
- **FR-024**: Closing terminal window MUST terminate app server gracefully (shutdown signal handling)
- **FR-025**: Closing browser window/tab MUST NOT terminate app server (server continues running)
- **FR-026**: App MUST check for updates on every launch by querying GitHub releases API
- **FR-027**: Update download MUST retrieve executable from GitHub releases assets
- **FR-028**: Update mechanism MUST use separate updater executable if required to avoid file locking when replacing running executable
- **FR-029**: Updater executable MUST handle closing main app, replacing executable file, and relaunching new version
- **FR-030**: Build process MUST investigate and document best approach for browser launching (auto-open vs terminal-only vs hybrid)
- **FR-031**: Build process MUST investigate and document whether two-executable architecture is necessary for self-updating on Windows
- **FR-032**: Build process MUST verify all bundled dependencies have compatible open source licenses
- **FR-033**: Executable distribution MUST include bundled licenses/ directory containing LICENSE.txt (app license), NOTICE.txt (Apache 2.0 attributions), and THIRD_PARTY_LICENSES.txt (all dependency licenses)
- **FR-034**: Build process MUST document any license requirements that affect distribution or usage terms
- **FR-035**: App MUST provide in-app "About" dialog accessible from footer displaying app version, credits, and open source licenses
- **FR-036**: About dialog MUST read license information from bundled licenses/ directory and display in user-friendly format with links to repositories
- **FR-037**: Automated release process MUST create GitHub release with proper structure when triggered
- **FR-038**: GitHub release MUST include descriptive title ("Burndown Chart v{version}"), automated changelog from commits/PRs, and clear installation instructions
- **FR-039**: GitHub release MUST upload Windows standalone package as ZIP asset containing both executables (app.exe + updater.exe)
- **FR-040**: Installation instructions MUST distinguish between "Windows Standalone" (download zip, extract, run) and "Run from Source" (clone/download source, install Python, run commands)
- **FR-041**: Windows ZIP asset MUST include: app.exe, updater.exe, README.txt (quick start guide), licenses/ directory with all dependency licenses, and document that database creates on first run
- **FR-042**: Release workflow MUST integrate with GitHub Actions or equivalent CI/CD for automated building and publishing
- **FR-043**: Release process MUST version executables consistently with git tags and app version metadata
- **FR-044**: Release notes MUST be automatically generated from conventional commits or pull request titles since last release

### Key Entities

- **Build Configuration**: Defines packaging settings (entry point, included files, dependencies, icon, version metadata)
- **Update Manifest**: Contains version information, download URL, release notes, minimum required version
- **Installation Context**: Tracks executable location, database path, logs path, read-only status, user permissions

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: Users without Python installed can download and run app within 2 minutes of receiving executable file
- **SC-002**: Executable file size under 100MB for practical download over typical internet connections
- **SC-003**: App launches within 5 seconds on systems without Python (comparable to native apps)
- **SC-004**: Automated build process completes in under 10 minutes from code to distributable executable
- **SC-005**: 90% of Windows 10+ systems run executable without requiring additional installations or configurations
- **SC-006**: Update check completes within 2 seconds without blocking app launch or user interface
- **SC-007**: Update download and installation completes within 5 minutes for typical executable size
- **SC-008**: Zero data loss when upgrading between versions using new update mechanism
- **SC-009**: Error logs capture 100% of unhandled exceptions with stack traces for debugging
- **SC-010**: Portable installation allows users to move executable and database to new location without configuration changes
- **SC-011**: Browser opens automatically within 3 seconds of launching executable for 95% of Windows users with default browser configured
- **SC-012**: Update check on launch completes without blocking app UI from appearing (non-blocking check)
- **SC-013**: Full update download and installation completes within 3 minutes for typical 100MB executable on standard broadband
- **SC-014**: Users can access complete license information for all bundled dependencies through in-app About dialog within 2 clicks

## Scope & Boundaries *(optional)*

### In Scope

- Windows executable packaging (PyInstaller or similar tool) producing two executables (app + updater)
- Automated build script for reproducible packaging integrated with CI/CD
- Automated GitHub release creation with proper formatting and assets
- Release structure: title, changelog, installation instructions, ZIP assets
- ZIP asset contents: app.exe, updater.exe, README.txt, licenses/ directory
- Clear installation instructions for both standalone (Windows) and source code (all platforms) approaches
- Digital code signing for executable
- Automatic update check on every launch with download from GitHub releases
- Two-executable architecture investigation for self-updating (if necessary)
- Browser auto-launch on startup with fallback to terminal display
- Terminal window management for server shutdown control
- Local database persistence in executable directory
- Error logging to files without terminal
- Version metadata in executable properties
- Splash screen during initialization
- Portable installation mode
- Source ZIP distribution option for Linux/macOS users
- In-app About dialog displaying licenses, version, and credits

### Out of Scope

- macOS or Linux executable packaging (Windows only for this feature)
- Installer/MSI packages (direct executable distribution)
- Auto-update without user interaction (manual download and restart)
- Cloud-based configuration sync across devices
- Multiple simultaneous installations on same machine
- Rollback to previous version after update
- Delta updates (full executable download required)
- Integration with Windows Store or package managers

### Prerequisites

âœ… **COMPLETED**: Feature 015 (SQLite Database Migration) has been merged to main branch. The packaged executable can now use database persistence reliably. Major merge on 2026-01-14 included SQLite persistence, budget tracking, DORA/Flow metrics enhancements, and comprehensive testing.

## Dependencies & Assumptions *(optional)*

### Dependencies

- **Feature 015 (SQLite Persistence)**: âœ… COMPLETED - Merged to main on 2026-01-14. Database-based persistence now available for packaged executable.
- PyInstaller or equivalent packaging tool for Python to executable conversion
- Code signing certificate for Windows executable signing
- GitHub Releases for hosting executables and version metadata
- **Investigation Required**: Best approach for browser auto-launching (webbrowser module vs system calls)
- **Investigation Required**: Whether two separate executables needed for self-updating (updater + main app) to avoid file locking issues on Windows
- **Investigation Required**: License compatibility of all bundled dependencies (Dash, Plotly, Waitress, etc.) and whether any require changes to app license or inclusion of additional license files
- **Investigation Required**: GitHub release best practices from recognized open-source projects (formatting, asset naming, installation instructions, changelog structure)

### Assumptions

- Users run Windows 10 or later (64-bit)
- Users have permissions to run executables (not restricted by corporate policies)
- Executable can write to its own directory for database and logs (not installed to Program Files)
- Internet connection available for update checks (offline mode supported but no updates)
- GitHub Releases or similar public hosting available for distribution
- Code signing certificate can be obtained for production releases

## Risk Assessment *(optional)*

### Technical Risks

- **Executable Size Bloat** (Medium Impact, High Likelihood): Bundling all dependencies may exceed 100MB target. Mitigate with dependency analysis, exclusion of unnecessary packages, and compression.
- **Antivirus False Positives** (High Impact, Medium Likelihood): Unsigned or improperly signed executables trigger Windows Defender. Mitigate with proper code signing certificate and reputation building.
- **Update Mechanism Complexity** (Medium Impact, High Likelihood): Replacing running executable is tricky on Windows. Mitigate with staged update process (download, prompt restart, replace on relaunch).
- **Missing System Dependencies** (Medium Impact, Low Likelihood): Some Windows systems lack required DLLs. Mitigate by bundling Visual C++ redistributables or using static linking.

### User Impact Risks

- **Download Size Barriers** (Low Impact, Medium Likelihood): 100MB executable may deter users on slow connections. Mitigate with compressed download and progress indication.
- **Security Concerns** (High Impact, Low Likelihood): Users may distrust unsigned executable from unknown source. Mitigate with code signing, HTTPS downloads, and clear documentation.
- **Update Notification Fatigue** (Low Impact, Medium Likelihood): Frequent update prompts annoy users. Mitigate with configurable update frequency and skip version option.

## Testing Strategy *(optional)*

### Unit Tests

- Test build script components (dependency detection, version extraction, file inclusion)
- Test update manifest parsing and validation
- Test portable database path detection logic
- Test log file rotation and cleanup

### Integration Tests

- Test full build process end-to-end (source code to executable)
- Test executable launches successfully on clean Windows VM
- Test database creation and persistence in executable directory
- Test update notification flow with mock update server
- Test update download and installation process
- Test portable mode (copy executable + database to new location)

### System Tests

- Test on multiple Windows versions (Windows 10, 11)
- Test on systems with/without Python installed
- Test with different antivirus software (Windows Defender, Norton, McAfee)
- Test in restricted environments (limited user permissions)
- Test read-only installation scenarios
- Test concurrent instances of executable

### User Acceptance Tests

- Verify non-technical users can download and run without help
- Verify update notification is clear and actionable
- Verify error messages are helpful when problems occur
- Verify app performance matches development mode
- Verify portable installation works as expected

### Performance Benchmarks (T113)

**Requirements vs. Actual Measurements**:

| Metric       | Requirement      | Actual              | Status                    |
| ------------ | ---------------- | ------------------- | ------------------------- |
| App Shutdown | <5s              | 2-3s                | âœ… PASS                    |
| App Launch   | <5s              | 2-3s                | âœ… PASS                    |
| Browser Open | <3s              | Included in launch  | âœ… PASS                    |
| Update Check | <2s non-blocking | 10-20s (background) | âœ… PASS (non-blocking met) |
| GitHub Build | <10 min          | ~5 min              | âœ… PASS                    |

**Observations**:
- All performance requirements met
- Update check runs in background thread without blocking app startup
- Shutdown via system tray cleanly terminates background process
- Launch time includes server startup + browser auto-open

## Implementation Notes *(optional)*

### Packaging Tool Selection

Recommended approach: **PyInstaller** with single-file mode
- Industry standard for Python to executable
- Good support for Dash and Plotly
- Can produce single-file executables
- Supports custom icons and version metadata

Alternative: **py2exe** or **cx_Freeze** if PyInstaller issues arise

### Dependency Management for Packaging

**Exclude Development/Test Dependencies**:

Packages to EXCLUDE from executable (development/testing only):
- `pytest` and all pytest plugins (pytest-cov, pytest-mock, etc.)
- `playwright` - browser automation for testing
- `pip-tools` (pip-compile) - dependency management
- `black`, `flake8`, `pylint` - code formatting/linting
- Any other packages in requirements-dev.txt or test requirements

**Implementation Approaches**:

1. **Separate Requirements Files**:
   - `requirements.txt` - production dependencies only
   - `requirements-dev.txt` - testing/development dependencies
   - PyInstaller uses only `requirements.txt`

2. **PyInstaller Hidden Imports**:
   - Use `--exclude-module pytest` etc. in build command
   - Create `.spec` file with explicit exclusions
   - Verify exclusions with `pyinstaller --log-level DEBUG`

3. **Validation**:
   - Extract executable contents to verify no test packages
   - Check file size meets <100MB target
   - Smoke test that app functions without test dependencies

**Expected Size Reduction**: Excluding test dependencies should save 30-50MB from executable

### GitHub Release Process Integration

**INVESTIGATION REQUIRED**: Research best practices from recognized open-source projects for GitHub releases.

**Example Projects to Study**:
- **VS Code**: https://github.com/microsoft/vscode/releases - Comprehensive release notes, multiple platform downloads, upgrade instructions
- **Electron**: https://github.com/electron/electron/releases - Clear versioning, breaking changes highlighted, detailed changelogs
- **Obsidian**: Professional release presentation (if available on GitHub)
- **PyInstaller itself**: https://github.com/pyinstaller/pyinstaller/releases - How packaging tools present their releases
- **Dash/Plotly**: Our main dependencies' release patterns

**GitHub Release Structure** (based on best practices):

```markdown
# Burndown Chart v{X.Y.Z}

**Release Date**: {YYYY-MM-DD}

## ðŸ“¦ Installation

### Windows Users (Recommended)
1. Download `burndown-chart-windows-v{X.Y.Z}.zip` from Assets below
2. Extract the ZIP file to your desired location
3. Run `BurndownChart.exe` (main app) - browser will open automatically
4. Close the terminal window to stop the app

**Note**: The updater (`BurndownChartUpdater.exe`) runs automatically when updates are available.

### Developers / Linux / macOS
1. Download Source Code (zip or tar.gz) from Assets below
2. Extract and navigate to directory
3. Install Python 3.13+
4. Run: `python -m venv .venv && .venv\Scripts\activate && pip install -r requirements.txt`
5. Run: `python app.py`
6. Open browser to http://127.0.0.1:8050

## ðŸš€ What's New

{AUTO-GENERATED CHANGELOG FROM COMMITS}

### Features
- feat: description from commit message
- feat: another feature

### Bug Fixes  
- fix: description from commit message

### Documentation
- docs: description from commit message

## ðŸ“‹ Full Changelog

**See all changes**: [v{X.Y.Z-1}...v{X.Y.Z}](link to compare)

## Assets

- `burndown-chart-windows-v{X.Y.Z}.zip` - Windows standalone package (app + updater executables)
- Source code (zip) - Auto-generated by GitHub
- Source code (tar.gz) - Auto-generated by GitHub
```

**Automation via GitHub Actions**:

1. **Trigger**: Git tag push (`v*.*.*`) or manual workflow dispatch
2. **Build Step**: 
   - Checkout code
   - Set up Python 3.13
   - Install dependencies (production only)
   - Run PyInstaller for both app.exe and updater.exe
   - Create licenses/ directory with all dependency licenses
   - Package into ZIP with README.txt
3. **Release Step**:
   - Generate changelog from commits since last tag (conventional commits)
   - Create GitHub release with formatted description
   - Upload ZIP asset
   - Tag as "Latest Release"
4. **Verification**:
   - Download artifact and smoke test
   - Verify version metadata matches tag

**Asset Naming Convention**:
- `burndown-chart-windows-v{version}.zip` - Clear, consistent, includes version
- Inside ZIP: `BurndownChart.exe`, `BurndownChartUpdater.exe` (PascalCase for Windows convention)

### Update Mechanism Architecture

**INVESTIGATION REQUIRED**: Determine best approach for self-updating Windows executable:

**Option A - Single Executable with Restart**:
1. **Update Check**: Query GitHub Releases API on every launch (non-blocking)
2. **Version Comparison**: Compare current version with latest release
3. **Download**: Download new executable to temp directory
4. **User Confirmation**: Prompt "Update available - Restart now?"
5. **Restart + Replace**: Launch batch script that waits for current process to exit, replaces exe, relaunches

**Option B - Two Executable Approach**:
1. **Main App**: Runs web server, checks for updates, downloads new version
2. **Updater Executable**: Small helper that handles replacement of main app while it's not running
3. **Update Flow**: Main app downloads update â†’ launches updater with parameters â†’ exits â†’ updater replaces main exe â†’ updater launches new main app â†’ updater exits
4. **Benefits**: Cleaner separation, avoids Windows file locking issues
5. **Tradeoffs**: Two files to distribute, slightly more complex

**Recommendation**: Research PyInstaller best practices and Windows file handling limitations before committing to architecture.

### Database Path Strategy

Portable mode priority:
1. Check for database in executable directory
2. If not found, check user AppData directory
3. If neither exists, create in executable directory (if writable)
4. If not writable, fallback to user AppData and warn about portability

### License Compliance Investigation

**INVESTIGATION REQUIRED**: Verify license compatibility for all bundled dependencies:

**Key Dependencies to Review**:
- **Dash** (MIT License) - Permissive, no restrictions
- **Plotly** (MIT License) - Permissive, no restrictions
- **Waitress** (ZPL 2.1 License) - Permissive, compatible with proprietary
- **Dash Bootstrap Components** (Apache 2.0) - Permissive, requires license notice
- **SQLAlchemy** (MIT License) - Permissive, no restrictions
- **Requests** (Apache 2.0) - Permissive, requires license notice
- **PyInstaller** (GPL with exception for bundled applications) - Can bundle without GPL contamination

**Investigation Steps**:
1. **Audit All Dependencies**: Run `pip-licenses` or similar tool to list all packages and their licenses
2. **Identify License Types**: Categorize as permissive (MIT, BSD, Apache) vs copyleft (GPL, LGPL, AGPL)
3. **Check Compatibility**: Verify no GPL dependencies without exceptions (would require app to be GPL)
4. **Document Requirements**: List any licenses requiring:
   - Attribution notices in distribution
   - Including original license text
   - Noting modifications made
   - Providing source code access
5. **Bundle License Files**: Create `licenses/` directory in executable with all required license texts
6. **Update App License**: Determine if app's MIT license needs modification or additional notices

**Expected Outcome**: 
- Most Python packages use permissive licenses (MIT, BSD, Apache 2.0)
- Apache 2.0 requires including NOTICE file with attributions
- PyInstaller's GPL has explicit exception allowing proprietary bundled apps
- Likely no changes needed to app's core license, but may need to include third-party notices

**Tools for Investigation**:
- `pip-licenses --format=markdown --output-file=dependency_licenses.md`
- Manual review of each package's LICENSE file on PyPI/GitHub
- Legal review if any ambiguous or restrictive licenses found

### Browser Launching Strategy

**INVESTIGATION REQUIRED**: Determine best UX for launching web app from executable:

**Option A - Auto-Launch Browser**:
- Use Python `webbrowser` module to open default browser automatically
- Benefits: Most convenient, minimal user action
- Risks: May be unexpected behavior, browser preference issues
- Fallback: If browser launch fails, display terminal with URL

**Option B - Terminal with URL**:
- Always show terminal window with clickable URL
- Benefits: User control, clear shutdown mechanism (close terminal)
- Tradeoffs: Less polished, requires extra click
- Enhancement: Add ASCII art/branding to terminal for professional appearance

**Option C - Hybrid Approach**:
- Auto-launch browser + keep terminal visible in background
- Terminal shows "App running at http://127.0.0.1:8050 - Close this window to exit"
- Benefits: Combines convenience with control
- Recommended: Start with this approach and gather user feedback

**Terminal Management**:
- Keep terminal open while server runs (provides shutdown control)
- Gracefully handle Ctrl+C for clean shutdown
- Display clear instructions: "Close this window to stop the app"

### Code Signing Process

1. Obtain code signing certificate (Sectigo, DigiCert, etc.)
2. Sign executable during build: `signtool.exe sign /f cert.pfx /p password app.exe`
3. Verify signature: `signtool.exe verify /pa app.exe`
4. Build reputation over time to reduce SmartScreen warnings
